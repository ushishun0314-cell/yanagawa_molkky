<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>やなモル</title>

<!-- PWA -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0ea5e9">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icons/icon-192.png">

<style>
  :root{
    --bg:#f7fafc; --card:#ffffff; --ink:#0f172a; --muted:#64748b; --acc:#0ea5e9; --ok:#10b981; --warn:#ef4444;
  }
  body{margin:0;background:#f7fafc;color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Yu Gothic UI",sans-serif}
  header{position:sticky;top:0;background:#fff;z-index:10;border-bottom:1px solid #e5e7eb}
  .head-inner{max-width:1080px;margin:0 auto;display:flex;align-items:center;gap:12px;padding:10px 16px}
  h1{font-size:18px;margin:0;display:flex;align-items:center;gap:8px}
  .logo{width:28px;height:28px;object-fit:cover;border-radius:6px}
  .container{max-width:1080px;margin:0 auto;padding:16px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .card{background:var(--card);border-radius:16px;box-shadow:0 2px 10px rgba(2,8,23,.06);padding:14px}

  /* プレイヤー設定（縦並び） */
  .players{display:flex;flex-direction:column;gap:10px}
  .player-row{
    display:flex;align-items:center;gap:10px;padding:10px;
    border:1px solid #e5e7eb;border-radius:12px;background:#fff;
  }
  .player-handle{
    width:34px;height:34px;border-radius:10px;border:1px solid #e5e7eb;
    display:flex;align-items:center;justify-content:center;background:#fff;
    font-size:18px;user-select:none;cursor:grab;flex:0 0 34px;
  }
  .player-row input{flex:1;min-height:42px;font-size:16px}
  .player-del{width:42px;height:42px;border-radius:10px;font-size:18px;line-height:1;cursor:pointer}

  /* 最近のプレイヤー名チップ */
  .chips{display:flex;flex-wrap:wrap;gap:8px}
  .chip-btn{
    border:1px solid #cfe7fb;background:#eef6ff;color:#0f172a;
    border-radius:999px;padding:6px 10px;font-size:14px;cursor:pointer;
  }
  .chip-btn:active{transform:translateY(1px)}

  input{width:100%;padding:10px;border:1px solid #e5e7eb;border-radius:10px}
  button{border:1px solid #e5e7eb;background:#fff;border-radius:12px;padding:10px 12px;font-size:14px;cursor:pointer}
  button.primary{border-color:var(--acc);color:#fff;background:var(--acc)}
  button.warn{border-color:var(--warn);background:var(--warn);color:#fff}
  button:disabled{opacity:.55;cursor:not-allowed}
  .pill{padding:4px 8px;border-radius:999px;background:#e5e7eb;color:#111;font-size:12px}
  .current{outline:2px solid var(--acc);border-radius:10px}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #e5e7eb;padding:8px;text-align:center;vertical-align:middle}
  th{font-weight:600;background:#f3f4f6}
  .muted{color:var(--muted)}
  .grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px}
  .badge{font-size:12px;border-radius:6px;background:#e5e7eb;padding:2px 6px}
  .winner{background:var(--ok);color:#fff}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;background:#111;color:#fff;padding:8px 12px;border-radius:10px;opacity:0;transition:.2s;pointer-events:none}
  .toast.show{opacity:1}
  .spacer{flex:1}
  .btn-alt{border-color:#d1d5db}

  /* 分析モーダル */
  .modalBG{position:fixed;inset:0;background:rgba(0,0,0,.25);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
  .modal{max-width:1040px;width:100%;background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.2);padding:16px;max-height:90vh;overflow:auto}
  .bar{height:10px;border-radius:6px;background:#e5e7eb;overflow:hidden}
  .bar > span{display:block;height:100%}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#eef6ff;border:1px solid #cfe7fb;font-size:12px}
  .note{font-size:12px;color:#64748b}
  .grid-heat{display:grid;grid-template-columns:repeat(6,minmax(40px,1fr));gap:6px}
  .cell{border:1px solid #e5e7eb;border-radius:8px;padding:6px}

  /* スマホ */
  @media (max-width: 640px){
    body{font-size:15px}
    .head-inner{padding:8px 12px}
    .container{padding:12px}
    th,td{padding:6px;font-size:13px}
    .grid{grid-template-columns:repeat(4,1fr);gap:6px}
    .grid button{padding:8px 6px;font-size:15px;min-height:38px}
    button{min-height:40px}
    input{min-height:40px}
    .player-row{padding:8px}
    .player-handle{width:30px;height:30px;font-size:16px}
    .player-del{width:38px;height:38px}
    .modal{width:100%;max-width:none;height:100svh;max-height:none;border-radius:0;padding:12px}
  }

  .tableWrap{overflow-x:auto}

  /* 勝利時カスタムモーダル（続行／終了） */
  .askBG{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:60;padding:20px}
  .ask{background:#fff;border-radius:14px;max-width:420px;width:100%;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .ask h3{margin:0 0 8px}
  .ask .row{justify-content:flex-end}
</style>
</head>
<body>
<header>
  <div class="head-inner">
    <img class="logo" src="icons/yanamol-hero.png" alt="やなモル">
    <h1>やなモル</h1>
    <div class="spacer"></div>
    <button id="openAnalytics" class="btn-alt">分析</button>
  </div>
</header>

<div class="container">
  <!-- セットアップ -->
  <section class="card" id="setup">
    <h2 style="margin:0 0 8px">プレイヤー</h2>

    <div id="playerList" class="players"></div>

    <!-- 最近のプレイヤー名チップ -->
    <div id="nameHistory" style="margin-top:8px"></div>

    <div class="row" style="margin-top:8px">
      <button id="addPlayerBtn">＋ プレイヤー追加</button>
      <button id="shuffleBtn" class="btn-alt">先攻シャッフル</button>
      <button id="startBtn" class="primary">ゲーム開始</button>
      <span class="muted">先頭の「≡」をドラッグで並び替え（先攻決め）</span>
    </div>
  </section>

  <!-- スコアボード -->
  <section class="card" id="board" style="display:none">
    <div class="row" style="justify-content:space-between">
      <div>現在の投擲: <span id="currentName" class="pill"></span></div>
      <div class="row">
        <button id="undoBtn" class="btn-alt">戻る</button>
        <button id="newGameBtn" class="btn-alt" title="終了後に使用">新しいゲーム（先攻ローテ）</button>
        <button id="resetBtn" class="warn">試合やり直し</button>
      </div>
    </div>

    <div class="tableWrap" style="margin-top:8px">
      <table id="scoreTable">
        <thead><tr id="scoreHead"></tr></thead>
        <tbody>
          <tr id="scoreRow"></tr>
          <tr id="remainRow"></tr>
          <tr id="statusRow"></tr>
        </tbody>
      </table>
    </div>

    <!-- 入力 -->
    <div>
      <h3 style="margin:8px 0">入力</h3>
      <div class="row"><span class="badge">単品（その番号が得点）</span></div>
      <div class="grid" id="singleRow"></div>
      <div class="row" style="margin-top:8px"><span class="badge">複数（倒した本数が得点）</span></div>
      <div class="grid" id="multiRow"></div>
      <div class="row" style="margin-top:8px">
        <button id="missBtn">ミス（0）</button>
        <button id="shareBtn" class="btn-alt">結果コピー</button>
      </div>
    </div>

    <div id="winnerBox" style="margin-top:12px"></div>
    <details style="margin-top:12px"><summary>履歴</summary>
      <div id="historyBox" class="muted" style="white-space:pre-wrap"></div>
    </details>
  </section>
</div>

<!-- 分析モーダル -->
<div class="modalBG" id="analyticsBG" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="anltTitle">
    <div class="row" style="justify-content:space-between">
      <div>
        <h2 id="anltTitle" style="margin:0">やなモル分析</h2>
        <div class="note">端末内データのみ（localStorage）。JSON/CSVでエクスポート・インポート可。日別サマリーCSVも出力。</div>
      </div>
      <div class="row">
        <button id="importJSON" class="btn-alt">JSONインポート</button>
        <button id="exportJSON" class="btn-alt">JSONエクスポート</button>
        <button id="exportCSV" class="btn-alt">CSVエクスポート</button>
        <button id="exportDailyCSV" class="btn-alt">日別サマリーCSV</button>
        <button id="closeAnalytics" class="primary">閉じる</button>
      </div>
    </div>
    <div id="analyticsBody" style="margin-top:10px"></div>
  </div>
</div>

<!-- 勝利時のカスタム確認モーダル -->
<div class="askBG" id="askBG">
  <div class="ask">
    <h3 id="askTitle">勝利</h3>
    <div id="askMsg" class="muted" style="margin-bottom:12px"></div>
    <div class="row">
      <button id="askCancel" class="btn-alt">終了</button>
      <button id="askOk" class="primary">続行</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
(() => {
  // ====== DB（ローカル保存） ======
  const DB_KEY = 'yanamol-db';
  const loadDB = () => { try{ return JSON.parse(localStorage.getItem(DB_KEY)||'{"games":[]}'); }catch{ return {games:[]}; } };
  const saveDB = (db) => localStorage.setItem(DB_KEY, JSON.stringify(db));
  const appendGame = (game) => { const db=loadDB(); db.games.push(game); saveDB(db); };

  // ====== 名前履歴 ======
  const NAME_KEY = 'yanamol-name-history';
  function loadNames(){ try{ return JSON.parse(localStorage.getItem(NAME_KEY) || '[]'); }catch{ return []; } }
  function saveNames(arr){ localStorage.setItem(NAME_KEY, JSON.stringify(arr)); }
  function rememberName(name){
    name = String(name||'').trim();
    if(!name) return;
    const arr = loadNames().filter(n => n !== name);
    arr.unshift(name);
    saveNames(arr.slice(0,12));
    renderNameHistory();
  }
  function renderNameHistory(){
    const box = $("#nameHistory");
    const names = loadNames();
    if(!names.length){ box.innerHTML = ''; return; }
    box.innerHTML = `<div class="muted" style="margin:4px 0 6px">最近のプレイヤー</div>`;
    const wrap = el('div',{class:'chips'});
    names.forEach(n=>{
      const b = el('button',{class:'chip-btn', text:n, title:`${n} を追加`});
      b.addEventListener('click', ()=>{
        addPlayer(n); renderSetup(); save();
      });
      wrap.appendChild(b);
    });
    box.appendChild(wrap);
  }

  // ====== ゲーム進行のstate ======
  const initState = () => ({
    players: [], // {id,name,score,misses,out,overResets}
    order: [],   // player ids in order（先攻＝index0）
    turnIdx: 0,
    history: [], // {pid, type:'single'|'multi'|'miss'|'over', value, prev, ts}
    finished: false,
    gameNo: 1,
    createdAt: Date.now(),
    gameId: null // yymmdd_n で後から採番
  });
  let state = load() || initState();

  // ====== DOM helper ======
  const $ = (sel)=>document.querySelector(sel);
  const el = (tag,attrs={})=>{ const n=document.createElement(tag); Object.entries(attrs).forEach(([k,v])=>{
    if(k==='text') n.textContent=v; else if(k==='html') n.innerHTML=v; else if(k==='class') n.className=v; else n.setAttribute(k,v);
  }); return n; };
  const toast=(msg)=>{ const t=$("#toast"); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1400); };

  // ====== storage for current session ======
  function save(){ localStorage.setItem('molkky-app', JSON.stringify(state)); }
  function load(){ try{ return JSON.parse(localStorage.getItem('molkky-app')||'null'); }catch{ return null; } }

  // ====== Setup UI ======
  const playerList = $("#playerList");
  function renderSetup(){
    playerList.innerHTML='';
    state.players.forEach((p,i)=>{
      const row = el('div',{class:'player-row'});

      const handle = el('div',{class:'player-handle', title:'ドラッグで並び替え', text:'≡'});
      row.append(handle);

      const input = el('input',{value:p.name, 'aria-label':'名前'});
      input.enterKeyHint = 'next';
      input.addEventListener('input', ()=>{
        p.name = input.value.trim().slice(0,20)||`P${i+1}`;
        save();
      });
      input.addEventListener('change', ()=>{ rememberName(input.value); });
      row.append(input);

      const delBtn = el('button',{class:'player-del', text:'✕', title:'削除'});
      delBtn.addEventListener('click', ()=>{
        state.players.splice(i,1);
        renderSetup(); save();
      });
      row.append(delBtn);

      // 並び替え
      row.draggable = true;
      row.addEventListener('dragstart', e=>{
        e.dataTransfer.setData('text/plain', i);
        row.style.opacity = .6;
      });
      row.addEventListener('dragend', ()=>{ row.style.opacity = 1; });
      row.addEventListener('dragover', e=>e.preventDefault());
      row.addEventListener('drop', e=>{
        e.preventDefault();
        const from = +e.dataTransfer.getData('text/plain');
        const to = i;
        if(from===to) return;
        const [moved] = state.players.splice(from,1);
        state.players.splice(to,0,moved);
        renderSetup(); save();
      });

      playerList.append(row);
    });

    if(state.players.length===0){
      const names = loadNames();
      if(names.length){
        names.slice(0,3).forEach(n=>addPlayer(n));
      }else{
        ['A','B','C'].forEach(n=>addPlayer(n));
      }
      renderSetup();
    }
  }
  function addPlayer(name){
    const id = self.crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random());
    state.players.push({id,name,score:0,misses:0,out:false,overResets:0});
  }

  $("#addPlayerBtn").addEventListener('click', ()=>{ addPlayer(`P${state.players.length+1}`); renderSetup(); save(); });
  $("#shuffleBtn").addEventListener('click', ()=>{
    for(let i=state.players.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [state.players[i],state.players[j]]=[state.players[j],state.players[i]];
    }
    renderSetup(); toast('順番をシャッフルしました'); save();
  });
  $("#startBtn").addEventListener('click', ()=>{
    state.players = state.players.filter(p=>p.name.trim()!=='');
    if(state.players.length<2){ toast('2人以上で開始してください'); return; }
    state.players.forEach(p => rememberName(p.name));

    state.order = state.players.map(p=>p.id);
    state.turnIdx = 0; state.history=[]; state.finished=false;
    state.players.forEach(p=>{ p.score=0; p.misses=0; p.out=false; p.overResets=0; });

    assignGameIdIfNeeded();
    applyOrderToPlayers();

    save(); switchToBoard();
  });

  // ====== Board ======
  const scoreHead = $("#scoreHead");
  const scoreRow = $("#scoreRow");
  const remainRow = $("#remainRow");
  const statusRow = $("#statusRow");

  function switchToBoard(){
    $("#setup").style.display='none';
    $("#board").style.display='';
    renderBoard();
  }
  function playerById(id){ return state.players.find(p=>p.id===id); }
  function aliveOrder(){ return state.order.filter(id=>!playerById(id).out); }
  function currentId(){ 
    const alive = aliveOrder(); 
    if(alive.length===0) return null;
    return alive[state.turnIdx % alive.length]; 
  }

  function renderBoard(){
    scoreHead.innerHTML='<th>項目</th>'+state.players.map(p=>`<th>${escapeHtml(p.name)}</th>`).join('');
    scoreRow.innerHTML=''; scoreRow.append(el('td',{text:'スコア'}));
    state.players.forEach(p=>{ scoreRow.append(el('td',{text:String(p.score)})); });

    remainRow.innerHTML=''; remainRow.append(el('td',{text:'残'}));
    state.players.forEach(p=>{
      const r = Math.max(0, 50 - p.score);
      const t = p.score>=50 ? '—' : `${r}`;
      remainRow.append(el('td',{html:`<span class="pill">${t}</span>`}));
    });

    statusRow.innerHTML=''; statusRow.append(el('td',{text:'状態'}));
    state.players.forEach(p=>{
      let s = '&nbsp;';
      if(p.score===50) s = '<span class="pill winner">勝者</span>';
      else if(p.out) s = '<span class="pill">失格</span>';
      else if(p.misses) s = `<span class="pill">ミス: ${p.misses}</span>`;
      statusRow.append(el('td',{html:s}));
    });

    const cid = currentId();
    const name = cid ? playerById(cid).name : '-';
    $("#currentName").textContent = name;
    [...scoreHead.children].forEach((th,i)=>{
      th.classList.toggle('current', cid && i===state.players.findIndex(p=>p.id===cid)+1);
    });

    renderWinnerBox();
    $("#newGameBtn").disabled = !state.finished;

    renderKeypads();
    renderHistory();
    save();
  }

  function renderKeypads(){
    const single = $("#singleRow"), multi=$("#multiRow");
    single.innerHTML=''; multi.innerHTML='';
    for(let n=1;n<=12;n++){
      const b = el('button',{text:String(n)});
      b.addEventListener('click', ()=>applyPlay({type:'single',value:n}));
      single.append(b);
    }
    for(let n=2;n<=12;n++){
      const b = el('button',{text:`${n}本`});
      b.addEventListener('click', ()=>applyPlay({type:'multi',value:n}));
      multi.append(b);
    }
  }

  $("#missBtn").addEventListener('click', ()=>applyPlay({type:'miss',value:0}));
  $("#undoBtn").addEventListener('click', undo);
  $("#resetBtn").addEventListener('click', ()=>{
    if(confirm('試合を最初からやり直しますか？')){ state = initState(); save(); location.reload(); }
  });
  $("#shareBtn").addEventListener('click', ()=>{
    const txt = exportText();
    navigator.clipboard?.writeText(txt).then(()=>toast('結果をコピーしました')).catch(()=>{ 
      const ta = el('textarea'); ta.value = txt; document.body.append(ta); ta.select(); document.execCommand('copy'); ta.remove(); toast('結果をコピーしました');
    });
  });
  $("#newGameBtn").addEventListener('click', ()=>{
    if(!state.finished && !confirm('進行中ですが新しいゲームを開始しますか？')) return;
    rotateFirst(); startNewGame();
  });

  // ====== 並び & 採番 ======
  function rotateFirst(){
    if(state.order.length>1){
      const first = state.order.shift();
      state.order.push(first);
    }
  }
  function applyOrderToPlayers(){
    const map = new Map(state.players.map(p => [p.id, p]));
    state.players = state.order.map(id => map.get(id)).filter(Boolean);
  }
  function assignGameIdIfNeeded(){
    if(state.gameId) return;
    const d = new Date(state.createdAt);
    const pad2 = n=>String(n).padStart(2,'0');
    const y = d.getFullYear()%100, m=pad2(d.getMonth()+1), day=pad2(d.getDate());
    const ymd = `${pad2(y)}${m}${day}`;
    const db = loadDB();
    const todayGames = db.games.filter(g=>{
      return typeof g.gameId==='string' && g.gameId.startsWith(`${ymd}_`);
    });
    const n = todayGames.length + 1;
    state.gameId = `${ymd}_${n}`;
  }

  function startNewGame(){
    state.createdAt = Date.now();
    state.gameId = null;
    assignGameIdIfNeeded();

    applyOrderToPlayers();

    state.players.forEach(p=>{ p.score=0; p.misses=0; p.out=false; p.overResets=0; });
    state.turnIdx = 0;
    state.history = [];
    state.finished = false;
    state.gameNo += 1;
    toast(`ゲーム ${state.gameNo} を開始（先攻ローテ適用）`);
    renderBoard();
  }

  // ====== 勝利モーダル：続行 / 終了 ======
  function askContinue(msg){
    return new Promise((resolve)=>{
      const bg = $("#askBG"); const ok=$("#askOk"); const cancel=$("#askCancel");
      $("#askTitle").textContent = "勝利";
      $("#askMsg").innerHTML = msg.replace(/\n/g,'<br>');
      bg.style.display='flex';
      const clean = ()=>{ ok.onclick=null; cancel.onclick=null; bg.style.display='none'; };
      ok.onclick = ()=>{ clean(); resolve(true); };      // 続行
      cancel.onclick = ()=>{ clean(); resolve(false); }; // 終了
    });
  }

  async function applyPlay({type,value}){
    if(state.finished) return;
    const cid = currentId(); if(!cid) return;
    const p = playerById(cid);
    const prev = {score:p.score,misses:p.misses,out:p.out,overResets:p.overResets};
    const ts = Date.now();
    let gained = 0;

    if(type==='miss'){
      p.misses += 1;
      if(p.misses>=3){ p.out = true; toast(`${p.name} は3回ミスで失格`); }
      state.history.push({pid:cid,type:'miss',value:0,prev,ts});
    }else{
      p.misses = 0; gained = value; p.score += gained;
      if(p.score===50){
        toast(`${p.name} が50点！`);
        p.out = true;
        state.history.push({pid:cid,type, value:gained,prev,ts});

        const remaining = aliveOrder().length;
        if(remaining>=2){
          const cont = await askContinue(`${p.name} が勝利しました。<br>残りのプレイヤーで続けますか？`);
          if(cont){
            state.players.forEach(pp=>{ if(!pp.out) pp.misses=0; });
            advanceTurn(); renderBoard(); return;
          } else {
            state.finished = true;
          }
        } else {
          state.finished = true;
        }
      } else if(p.score>50){
        p.score = 25; p.overResets += 1; 
        toast(`${p.name} はオーバー！25点へ`);
        state.history.push({pid:cid,type:'over', value:gained,prev,ts});
      } else {
        state.history.push({pid:cid,type, value:gained,prev,ts});
      }
    }

    advanceTurn();
    if(aliveOrder().length===0){ state.finished=true; }
    if(state.finished){ persistGame(); }
    renderBoard();
  }

  function advanceTurn(){
    const alive = aliveOrder();
    if(alive.length===0){ state.turnIdx = 0; return; }
    state.turnIdx = (state.turnIdx + 1) % alive.length;
  }

  function undo(){
    const h = state.history.pop(); if(!h) return;
    const aliveNow = aliveOrder();
    if(aliveNow.length>0){
      state.turnIdx = (state.turnIdx - 1 + aliveNow.length) % aliveNow.length;
    } else {
      state.turnIdx = 0;
    }
    const p = playerById(h.pid);
    p.score = h.prev.score; p.misses = h.prev.misses; p.out = h.prev.out; p.overResets = h.prev.overResets;
    state.finished = false;
    renderBoard();
  }

  function exportText(){
    const lines = [];
    lines.push(`【やなモル 結果】（Game ${state.gameNo} / ID: ${state.gameId})`);
    state.players.forEach(p=>{
      const status = p.out && p.score<50 ? '（失格）' : (p.score===50?'（勝者）':'');
      lines.push(`${p.name}: ${p.score}点 ${status}`);
    });
    lines.push('— 記録 —');
    state.history.forEach((h,i)=>{
      const p = playerById(h.pid);
      const t = h.type==='miss'?'ミス':(h.type==='single'?`単品${h.value}`:h.type==='over'?`オーバー(${h.value})→25`:`複数${h.value}本`);
      lines.push(`${i+1}. ${p.name} → ${t}`);
    });
    return lines.join('\n');
  }

  function renderHistory(){
    const box = $("#historyBox");
    box.textContent = state.history.map((h,i)=>{
      const p = playerById(h.pid);
      const t = h.type==='miss'?'ミス':(h.type==='single'?`単品${h.value}`:h.type==='over'?`オーバー(${h.value})→25`:`複数${h.value}本`);
      return `${String(i+1).padStart(2,' ')}. ${p.name} → ${t}`;
    }).join('\n');
  }

  function renderWinnerBox(){
    const wb = $("#winnerBox");
    const winners = state.players.filter(p=>p.score===50);
    if(winners.length){
      const names = winners.map(p=>escapeHtml(p.name)).join('、');
      const aliveCnt = aliveOrder().length;
      let html = `<div class="pill winner">勝者：${names} 🎉</div>`;
      if(!state.finished && aliveCnt>=2){
        html += `<div class="muted" style="margin-top:6px">残りのプレイヤーで続行中</div>`;
      }
      if(state.finished){
        html += `<div style="margin-top:8px"><button id="finishNewGameBtn" class="primary">新しいゲーム（先攻ローテ）</button></div>`;
      }
      wb.innerHTML = html;
      document.querySelector("#finishNewGameBtn")?.addEventListener('click', ()=>{ rotateFirst(); startNewGame(); });
    } else {
      wb.innerHTML = '';
    }
  }

  function persistGame(){
    const db = loadDB();
    if(db.games.some(g=>g.gameId===state.gameId)) return;

    const players = state.players.map(p=>({id:p.id,name:p.name}));
    const winners = state.players.filter(p=>p.score===50).map(p=>p.id);
    const game = {
      gameId: state.gameId,
      startedAt: state.createdAt,
      endedAt: Date.now(),
      players,
      winners,
      order: state.order.slice(),
      plays: state.history.map(h=>({
        ts: h.ts, pid: h.pid, type: h.type, value: h.value,
        scoreBefore: h.prev.score, missesBefore: h.prev.misses
      }))
    };
    appendGame(game);
    toast('試合データを保存しました');
  }

  function escapeHtml(str){ return String(str).replace(/[&<>"']/g,s=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[s])); }

  // ====== 分析モーダル ======
  $("#openAnalytics").addEventListener('click', ()=>{
    renderAnalytics(); $("#analyticsBG").style.display='flex'; $("#analyticsBG").setAttribute('aria-hidden','false');
  });
  $("#closeAnalytics").addEventListener('click', ()=>{
    $("#analyticsBG").style.display='none'; $("#analyticsBG").setAttribute('aria-hidden','true');
  });

  // JSONインポート
  $("#importJSON").addEventListener('click', ()=>{
    const input = document.createElement('input');
    input.type = 'file'; input.accept = 'application/json';
    input.onchange = async (e)=>{
      const file = e.target.files[0]; if(!file) return;
      try{
        const text = await file.text();
        const incoming = JSON.parse(text);
        if(!incoming || !Array.isArray(incoming.games)) throw new Error('形式が不正です（gamesがありません）');

        const db = loadDB();
        let add = 0, skip = 0;
        incoming.games.forEach(g=>{
          if(db.games.some(x=>x.gameId===g.gameId)){ skip++; return; }
          db.games.push(g); add++;
        });
        saveDB(db);
        toast(`インポート完了：追加 ${add} / 重複スキップ ${skip}`);
        renderAnalytics();
      }catch(err){
        console.error(err);
        alert('読み込みに失敗しました。JSONの形式をご確認ください。');
      }
    };
    input.click();
  });

  // エクスポート（生データ）
  $("#exportJSON").addEventListener('click', ()=>{
    const db = loadDB(); const blob = new Blob([JSON.stringify(db,null,2)],{type:'application/json'});
    const url = URL.createObjectURL(blob); download(url,'yanamol-data.json');
  });
  // エクスポート（CSV）
  $("#exportCSV").addEventListener('click', ()=>{
    const db = loadDB();
    const rows = [['gameId','ts','date','player','type','value','scoreBefore','missesBefore']];
    db.games.forEach(g=>{
      const date = (new Date(g.startedAt)).toISOString().slice(0,10);
      const nameById = Object.fromEntries(g.players.map(p=>[p.id,p.name]));
      g.plays.forEach(p=>{
        rows.push([g.gameId, new Date(p.ts).toISOString(), date, nameById[p.pid]||p.pid, p.type, p.value, p.scoreBefore, p.missesBefore]);
      });
    });
    const csv = rows.map(r=>r.map(x=>String(x).includes(',')?`"${String(x).replace(/"/g,'""')}"`:String(x)).join(',')).join('\n');
    const blob = new Blob([csv],{type:'text/csv'}); const url = URL.createObjectURL(blob); download(url,'yanamol-data.csv');
  });
  // エクスポート（日別サマリー）
  $("#exportDailyCSV").addEventListener('click', ()=>{
    const db = loadDB();
    const sum = new Map(); // key=date|name -> stats
    const getKey = (date,name)=>`${date}|${name}`;
    db.games.forEach(g=>{
      const date = (new Date(g.startedAt)).toISOString().slice(0,10);
      const nameById = Object.fromEntries(g.players.map(p=>[p.id,p.name]));
      const gameWinners = new Set(g.winners);

      // 初期化（ゲーム参加/勝ち）
      g.players.forEach(pl=>{
        const name = pl.name;
        const key = getKey(date,name);
        if(!sum.has(key)) sum.set(key,{games:0,wins:0,throws:0,points:0,miss:0,single:0,multi:0});
        sum.get(key).games += 1;
        if(gameWinners.has(pl.id)) sum.get(key).wins += 1;
      });

      g.plays.forEach(p=>{
        const name = nameById[p.pid] || p.pid;
        const key = getKey(date,name);
        if(!sum.has(key)) sum.set(key,{games:0,wins:0,throws:0,points:0,miss:0,single:0,multi:0});
        sum.get(key).throws += 1;
        if(p.type==='miss'){ sum.get(key).miss += 1; }
        else{
          const add = p.value||0; sum.get(key).points += add;
          if(p.type==='single') sum.get(key).single += 1;
          if(p.type==='multi')  sum.get(key).multi  += 1;
        }
      });
    });

    const rows = [['date','player','games','wins','win_rate(%)','throws','points','avg_per_throw','single(%)','multi(%)','miss(%)']];
    sum.forEach((v,key)=>{
      const [date,name] = key.split('|');
      const denomScore = (v.single+v.multi)||1;
      const winRate = v.games? (v.wins/v.games*100):0;
      const avg = v.throws? (v.points/v.throws):0;
      const singlePct = (v.single/denomScore*100);
      const multiPct = (v.multi/denomScore*100);
      const missPct = v.throws? (v.miss/v.throws*100):0;
      rows.push([date,name,v.games,v.wins,winRate.toFixed(1),v.throws,v.points,avg.toFixed(2),singlePct.toFixed(1),multiPct.toFixed(1),missPct.toFixed(1)]);
    });

    const csv = rows.map(r=>r.join(',')).join('\n');
    const blob = new Blob([csv],{type:'text/csv'}); const url = URL.createObjectURL(blob); download(url,'yanamol-daily-summary.csv');
  });

  function download(url, filename){
    const a = document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),1000);
  }

  function renderAnalytics(){
    const host = $("#analyticsBody"); host.innerHTML='';
    const db = loadDB();
    if(!db.games.length){
      host.innerHTML = `<div class="muted">まだ保存された試合はありません。まずは1試合プレイしてみてください。</div>`;
      return;
    }

    // 概要
    const allPlays = db.games.reduce((acc,g)=>acc+g.plays.length,0);
    const totalDurationMs = db.games.reduce((acc,g)=>acc+(g.endedAt-g.startedAt),0);
    const avgSecPerTurn = allPlays? (totalDurationMs/1000/allPlays):0;
    const head = el('div',{class:'row'});
    head.append(el('div',{class:'chip',html:`総試合 <b>${db.games.length}</b>`}));
    head.append(el('div',{class:'chip',html:`総投擲 <b>${allPlays}</b>`}));
    head.append(el('div',{class:'chip',html:`平均/投擲 <b>${avgSecPerTurn.toFixed(1)}s</b>`}));
    host.appendChild(head);

    // プレイヤー集計（勝率・単品/複数比率・先攻初投平均）
    const stat = new Map(); // name -> stats
    const firstIdOfGame = g=> g.order[0];

    db.games.forEach(g=>{
      const nameById = Object.fromEntries(g.players.map(p=>[p.id,p.name]));

      g.players.forEach(pl=>{
        const name = pl.name;
        if(!stat.has(name)) stat.set(name,{
          games:0,wins:0,throws:0,points:0,miss:0,single:0,multi:0,over:0,
          firstThrows:0,firstPoints:0, // 先攻での全投（参考）
          lateThrows:0, latePoints:0,  // 後攻での全投（参考）
          heat: Array(13).fill(0),
          // 先攻“初投”だけの集計
          ft1Count:0, ft1Points:0
        });
      });

      // 先攻の初投検出用
      const leaderId = firstIdOfGame(g);
      let leaderFirstTaken = false;

      g.plays.forEach(p=>{
        const name = nameById[p.pid] || p.pid; 
        const s = stat.get(name);
        s.throws += 1;
        const addForAvg = (p.type==='miss') ? 0 : (p.value||0);

        // 参考：先攻/後攻の全投
        if(p.pid === leaderId){ s.firstThrows += 1; s.firstPoints += addForAvg; }
        else                  { s.lateThrows  += 1; s.latePoints  += addForAvg; }

        // ★ 先攻プレイヤーの「そのゲーム最初の1投」だけを一度だけ拾う
        if (!leaderFirstTaken && p.pid === leaderId){
          const leaderName = nameById[leaderId] || leaderId;
          const sl = stat.get(leaderName);
          sl.ft1Count += 1;
          sl.ft1Points += addForAvg;
          leaderFirstTaken = true;
        }

        // 得点内訳
        if(p.type==='miss'){
          s.miss += 1;
        }else{
          s.points += addForAvg;
          if(p.type==='single'){ s.single += 1; if(p.value>=1 && p.value<=12) s.heat[p.value] += 1; }
          else if(p.type==='multi'){ s.multi += 1; }
          else if(p.type==='over'){ s.over += 1; }
        }
      });

      const nameByIdWin = Object.fromEntries(g.players.map(p=>[p.id,p.name]));
      g.players.forEach(pl=>{ const name = pl.name; stat.get(name).games += 1; });
      g.winners.forEach(pid=>{ const name = nameByIdWin[pid] || pid; stat.get(name).wins += 1; });
    });

    const table = document.createElement('table');
    table.innerHTML = `
      <thead>
        <tr>
          <th>プレイヤー</th><th>試合</th><th>勝</th><th>勝率</th><th>投擲</th>
          <th>総得点</th><th>平均/投擲</th><th>ミス率</th>
          <th>先攻 初投平均</th>
          <th>後攻 平均/投</th>
          <th>単品比率</th><th>複数比率</th>
        </tr>
      </thead>
      <tbody></tbody>`;
    const tbody = table.querySelector('tbody');

    let maxAvg = 0; stat.forEach(s=>{ const avg = s.throws? (s.points/s.throws):0; if(avg>maxAvg) maxAvg=avg; });
    stat.forEach((s,name)=>{
      const avg = s.throws? (s.points/s.throws):0;
      const missRate = s.throws? (s.miss/s.throws*100):0;
      const lateAvg  = s.lateThrows ? (s.latePoints /s.lateThrows ):0;
      const ft1Avg   = s.ft1Count   ? (s.ft1Points /s.ft1Count   ):0;
      const denomScore = (s.single + s.multi) || 1;
      const singlePct = s.single/denomScore*100;
      const multiPct  = s.multi /denomScore*100;
      const winRate   = s.games? (s.wins/s.games*100):0;

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td style="text-align:left;font-weight:600">${escapeHtml(name)}</td>
        <td>${s.games}</td>
        <td>${s.wins}</td>
        <td>${winRate.toFixed(1)}%</td>
        <td>${s.throws}</td>
        <td>${s.points}</td>
        <td>
          <div class="bar"><span style="width:${maxAvg? (avg/maxAvg*100):0}%; background:${avg>=4?'#10b981':'#60a5fa'}"></span></div>
          <div class="note">${avg.toFixed(2)}</div>
        </td>
        <td>
          <div class="bar"><span style="width:${missRate}%; background:#fda4af"></span></div>
          <div class="note">${missRate.toFixed(1)}%</div>
        </td>
        <td>${ft1Avg.toFixed(2)} <span class="note">(${s.ft1Count})</span></td>
        <td>${lateAvg.toFixed(2)}</td>
        <td>${singlePct.toFixed(1)}% <span class="note">(${s.single})</span></td>
        <td>${multiPct.toFixed(1)}% <span class="note">(${s.multi})</span></td>`;
      tbody.appendChild(tr);
    });
    host.appendChild(table);

    // 単品ヒートマップ
    const heatWrap = el('div', {style:'margin-top:10px'});
    heatWrap.append(el('h3',{text:'単品ヒートマップ（1-12）'}));
    const maxCount = Array.from(stat.values()).reduce((m,s)=>Math.max(m, ...(s.heat||[0])),0) || 1;
    stat.forEach((s,name)=>{
      const sec = el('div',{class:'card', style:'margin-top:6px'});
      sec.append(el('div',{html:`<b>${escapeHtml(name)}</b>`}));
      const grid = el('div',{class:'grid-heat'});
      for(let n=1;n<=12;n++){
        const c = s.heat[n]||0; const pct = Math.round((c/maxCount)*100);
        const cell = el('div',{class:'cell', html:`<div>${n}</div><div class="note">${c}</div>`, style:`background:linear-gradient(0deg, rgba(14,165,233,0.${Math.min(9,Math.max(1,Math.ceil(pct/12)))}) ${pct}%, rgba(255,255,255,1) ${pct}%);`});
        grid.append(cell);
      }
      sec.append(grid); heatWrap.append(sec);
    });
    host.appendChild(heatWrap);
  }

  // 起動
  renderSetup();
  renderNameHistory();
  if(state.players.length && state.order.length){ switchToBoard(); renderBoard(); }
})();
</script>

<!-- PWA: SW 登録 -->
<script>
if('serviceWorker' in navigator){
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js').catch(console.error);
  });
}
</script>
</body>
</html>
